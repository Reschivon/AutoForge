
import itertools
from typing import Collection, Dict, List, Set, Tuple
import libcst as cst
from libcst.metadata import PositionProvider
from autoplag import DirectedGraph, AssignType, first_line, \
    get_assignment_targets, isinstance_AssignType, isinstance_ControlFlow, get_expression_ControlFlow
        
def empty(l):
    '''
    Suprisingly useful
    '''
    return len(l) == 0

def stringify(s, ast):
    '''
    Calls first_line on a Collection of nodes
    '''
    return [first_line(ss, ast) for ss in s]

def get_all_usages(node: cst.CSTNode):
    '''
    Return all used objects in a function. This handles regular statements,
    assignments (where the assign-target is ignored), function calls, etc
    '''
    
    assert not isinstance(node, cst.Name), 'Call this function on full statements, not parts of one'
    
    uses: List[cst.Name] = []
    
    def treewalk(node):
        '''
        Walk the tree, looking for used variables, and add such names to the uses list
        
        Why treewalk and not cst.Visitor? Because we do complex type checks like isinstance_AssignType
        Which is no supported by the visitor machinery
        '''
        
        if isinstance(node, cst.Name):
            # Base case
            uses.append(node.value)
            
        elif isinstance(node, cst.Attribute):
            # So we may get nested assignntypes like x.y.z
            # In such a case we must generate a using name like 'x.y.z`
            # and not simply 'x.y' or 'z' or etc.
            def gen_attr_name_nested(node):
                
                if isinstance(node, cst.Name):
                    # Base case
                    return node.value
                elif isinstance(node, cst.Attribute):
                    return gen_attr_name_nested(node.value) \
                        + '.' \
                        + gen_attr_name_nested(node.attr)
                
                else:
                    raise Exception()
                     
            uses.append(gen_attr_name_nested(node))
            
        elif isinstance(node, cst.CompFor):
            # For something like for a in b, a is NOT a use
            treewalk(node.iter)
            if hasattr(node, 'inner_comp_for'): 
                treewalk(node.inner_comp_for)
            
        elif isinstance_AssignType(node):
            # Ignore the target part
            # Note CompFor is Assigntype but it's handled specially above
            treewalk(node.value)
                        
        elif isinstance_ControlFlow(node):
            # For control flow, only count the expression, ignore the body.
            treewalk(get_expression_ControlFlow(node))
            
        elif isinstance(node, cst.Call):
            # For calls, it may mutate the calle and arguments, so they are
            # counted as USEs. Additionally, the function itself is counted too
            
            if isinstance(node.func, cst.Attribute):
                # Caller name
                uses.append(node.func.value.value)
                # function name
                uses.append(node.func.attr.value)
                
                for a in node.args:
                    treewalk(a)
                
            elif isinstance(node.func, cst.Name):
                # function name
                uses.append(node.func.value)
                for a in node.args:
                    treewalk(a)
            else:
                raise Exception()
                        
        else:
            assert isinstance(node, cst.CSTNode)
            # Recurse all children, no special treatment
            for child in node.children:
                treewalk(child)
                
    treewalk(node)
    return uses

def intersects(a: Collection, b: Collection) -> bool:
    return len(set(a).intersection(set(b))) > 0
    
def run_rda(cfg: DirectedGraph, ast: cst.Module):  
    '''
    Given a CFG (generated by cfg.py) and the original cst, this will compute IN/OUT sets per instruction
    
    https://en.wikipedia.org/wiki/Reaching_definition
    
    Note that nothing is returned, rather, the IN/OUT sets are added to the cfg. You can access by iterating 
    over each statement in each basicblock of the cfg. Within each statement are the .ins and .out members
    
    for chunk in cfg:
        for stmt_data in chunk.stmts:
            print(stmt_data.ins, stmt_data.outs)
    '''  
    
    # Collect all definitions and build gen
    all_defs: List[Tuple[str, AssignType]] = []
    
    for chunk in cfg:
        for stmt_data in chunk.stmts:
            
            gen_names = get_assignment_targets(stmt_data.node)
            if empty(gen_names): continue
            
            # Add this stmt to its gen set
            # Yes, it's kinda redundant to add a statment to its own gen set
            # This is just here to be symmetrical to the kill set -- which
            # also contains a List of AssignType to reference other parts of the code
            stmt_data.gens.add(stmt_data.node)
            
            # Add name -> stmt mapping to all_defs
            gen_pairs = zip(gen_names, [stmt_data.node] * len(gen_names))
            all_defs.extend(gen_pairs)
            
    # Add function arguments to all_defs
    # Note the statement reference will just be the FunctionDef itself
    arg_gen_names = get_all_usages(cfg.func.params)
    arg_gen_pairs = zip(arg_gen_names, [cfg.func] * len(arg_gen_names))
    all_defs.extend(arg_gen_pairs)
    
    # print('all_defs', [name + ': ' + first_line(s, ast) for name, s in all_defs])
    
    # Find assignments and build kill         
    for chunk in cfg:
        for stmt_data in chunk.stmts:
            # Get variable names of all gens
            gens = get_assignment_targets(stmt_data.node)
                        
            # Find all statements that generate a name that we kill here
            defs_intersected: List[Tuple[str, AssignType]] = list(filter(lambda deff: deff[0] in gens, all_defs))
            
            if empty(defs_intersected): continue
            
            names_intersected, stmts_intersected = zip(*defs_intersected)
            stmts_intersected: List[AssignType] = set(stmts_intersected)
            
            # Do not put yourself in the kill set
            stmts_intersected.remove(stmt_data.node)
            stmt_data.kills.update(stmts_intersected)
            
    
    # Add dummy statements to empty chunks so the propagration works correctly
    for chunk in cfg:
        if empty(chunk.stmts):
            chunk.append(cst.Comment('# Empty BB')) 
            
    # Do IN/OUT
    while True:
        # If any OUT set is updated, this is set to True
        changed = False
        
        for chunk in cfg:
            chunk_size = len(chunk.stmts)
            for i in range(chunk_size): 
                # Get the UNION of predecessors. Note predecessors are _statements_ and not BBs as some other
                # implementations do
                if i == 0:
                    # Since we can't access statements directly, we'll actually get the predecessor _chunks_
                    # and then extract the last statement from each
                    sets_to_merge = [c[-1].outs for c in cfg.parents(chunk)]
                    
                    # If this is the first block, then ins include the arguments
                    chunk[i].ins = set().union(*sets_to_merge)
                else:
                    chunk[i].ins = chunk[i - 1].outs
                                        
                # Gen and kill are disjoint, so no need to worry about order
                # Most RDA literature enforces a weird precedence like OUT = GEN + (IN - KILL) 
                working_set = chunk[i].ins.copy()
                working_set.update(chunk.stmts[i].gens)
                working_set.difference_update(chunk.stmts[i].kills)
                
                if working_set != chunk[i].outs: changed = True
                
                chunk[i].outs = working_set
            
        # The only way to end the loop is here    
        if not changed: break
    
    # Set deps
    # TODO handle nasty edge cases better
    for chunk in cfg:
        for stmt_data in chunk.stmts:
            # Figure out uses
            stmt_data.uses = get_all_usages(stmt_data.node)
                
            # Find all members of IN set that intersect our use set
            # Because IN is a set of stmts which use is a set of variable names,
            # we have to first map each IN set item to its defined variable names
            for in_set_stmt in stmt_data.ins:
                variables_defined = get_assignment_targets(in_set_stmt)
                defines_a_var_in_use_set = intersects(stmt_data.uses, variables_defined)
                
                if defines_a_var_in_use_set: stmt_data.deps.add(in_set_stmt)
                
            # Find all members of IN set that intersect our kill set
            stmt_data.deps.update(stmt_data.kills.intersection(stmt_data.ins))
                    
                    
    print('\n\n====== RDA results for', first_line(cfg.func, ast))
    
    # Print gen/kill
    print()
    for chunk in cfg:
        for stmt_data in chunk.stmts: 
            
            print(first_line(stmt_data.node, ast), 
                    # 'gens', [first_line(gen, ast) for gen in stmt_data.gens], \
                    #   '\tkills', [first_line(s, ast) for s in stmt_data.kills], \
                  '\n\tins', stringify(stmt_data.ins, ast), \
                  '\n\touts', stringify(stmt_data.outs, ast), \
                  '\n\tuses', stringify(stmt_data.uses, ast), \
                  '\n\tkills', stringify(stmt_data.kills, ast))
            
            print()
        
    # Print deps
    print()
    for chunk in cfg:
        for stmt_data in chunk.stmts: 
            
            print(first_line(stmt_data.node, ast), \
                  '\n\tDEPS:', 
                # 'gens', [first_line(gen, ast) for gen in stmt_data.gens], \
                #   '\tkills', [first_line(s, ast) for s in stmt_data.kills], \
                  ' ', [first_line(s, ast) for s in stmt_data.deps] )
            
            print()
    