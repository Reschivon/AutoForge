
import itertools
from typing import Collection, Dict, List, Set, Tuple
import libcst as cst
from libcst.metadata import PositionProvider
from autoplag import DirectedGraph, AssignType, first_line, \
    get_assignment_targets, isinstance_AssignType, isinstance_ControlFlow, isinstance_NonWhitespace, get_expression_ControlFlow
        
def empty(l):
    '''
    Suprisingly useful
    '''
    return len(l) == 0

def stringify(s, ast):
    '''
    Calls first_line on a Collection of nodes
    '''
    return [first_line(ss, ast) for ss in s]

def get_all_names(node: cst.CSTNode):
    '''
    Return all references to a name.
    Beware: includes assignments on top of usages
    '''
    
    # Special case: the visitor only works for children of the given node,
    # so if the node itself is a cst.Name it won't work
    if isinstance(node, cst.Name):
        return node.value
    
    class UsesVisitor(cst.CSTVisitor):
        def __init__(self) -> None:
            self.names: List[cst.Name] = []

        def visit_Name(self, node: cst.Name) -> bool:
            self.names.append(node.value)
            return True  # Recurse for whole subtree
        
    visitor = UsesVisitor()
    node._visit_and_replace_children(visitor)
    return visitor.names

def intersects(a: Collection, b: Collection) -> bool:
    return len(set(a).intersection(set(b))) > 0
    
def run_rda(cfg: DirectedGraph, ast: cst.Module):  
    '''
    Given a CFG (generated by cfg.py) and the original cst, this will compute IN/OUT sets per instruction
    
    https://en.wikipedia.org/wiki/Reaching_definition
    
    Note that nothing is returned, rather, the IN/OUT sets are added to the cfg. You can access by iterating 
    over each statement in each basicblock of the cfg. Within each statement are the .ins and .out members
    
    for chunk in cfg:
        for stmt_data in chunk.stmts:
            print(stmt_data.ins, stmt_data.outs)
    '''  
    wrapper = cst.MetadataWrapper(ast)
    position = wrapper.resolve(PositionProvider)
    
    # Collect all definitions and build gen
    all_defs: List[Tuple[str, AssignType]] = []
    
    for chunk in cfg:
        for stmt_data in chunk.stmts:
            
            gen_names = get_assignment_targets(stmt_data.stmt)
            if empty(gen_names): continue
            
            # Add this stmt to its gen set
            # Yes, it's kinda redundant to add a statment to its own gen set
            # This is just here to be symmetrical to the kill set -- which
            # also contains a List of AssignType to reference other parts of the code
            stmt_data.gens.add(stmt_data.stmt)
            
            # Add name -> stmt mapping to all_defs
            gen_pairs = zip(gen_names, [stmt_data.stmt] * len(gen_names))
            all_defs.extend(gen_pairs)
            
    # print('all_defs', [name + ': ' + first_line(s, ast) for name, s in all_defs])
    
    # Find assignments and build kill         
    for chunk in cfg:
        for stmt_data in chunk.stmts:
            # Get variable names of all gens
            gens = get_assignment_targets(stmt_data.stmt)
                        
            # Find all statements that generate a name that we kill here
            defs_intersected: List[Tuple[str, AssignType]] = list(filter(lambda deff: deff[0] in gens, all_defs))
            
            if empty(defs_intersected): continue
            
            names_intersected, stmts_intersected = zip(*defs_intersected)
            stmts_intersected: List[AssignType] = set(stmts_intersected)
            
            # Do not put yourself in the kill set
            stmts_intersected.remove(stmt_data.stmt)
            stmt_data.kills.update(stmts_intersected)
            
    
    # Add dummy statements to empty chunks so the propagration works correctly
    for chunk in cfg:
        if empty(chunk.stmts):
            chunk.append(cst.Comment('# Empty BB')) 
            
    # Do IN/OUT
    while True:
        # If any OUT set is updated, this is set to True
        changed = False
        
        for chunk in cfg:
            chunk_size = len(chunk.stmts)
            for i in range(chunk_size): 
                # Get the UNION of predecessors. Note predecessors are _statements_ and not BBs as some other
                # implementations do
                if i == 0:
                    # Since we can't access statements directly, we'll actually get the predecessor _chunks_
                    # and then extract the last statement from each
                    sets_to_merge = [c[-1].outs for c in cfg.parents(chunk)]
                    
                    chunk[i].ins = set().union(*sets_to_merge)
                else:
                    chunk[i].ins = chunk[i - 1].outs
                                        
                # Gen and kill are disjoint, so no need to worry about order
                # Most RDA literature enforces a weird precedence like OUT = GEN + (IN - KILL) 
                working_set = chunk[i].ins.copy()
                working_set.update(chunk.stmts[i].gens)
                working_set.difference_update(chunk.stmts[i].kills)
                
                if working_set != chunk[i].outs: changed = True
                
                chunk[i].outs = working_set
            
        # The only way to end the loop is here    
        if not changed: break
    
    # Set deps
    # TODO handle nasty edge cases better
    for chunk in cfg:
        for stmt_data in chunk.stmts:
            # Figure out uses
            if isinstance_AssignType(stmt_data.stmt):
                # Special case for assign types: do not call get_all_names on the whole
                # node because that'll include the assign-targets, which are NOT usages
                # instead we get all names in the expression part
                stmt_data.uses = get_all_names(stmt_data.stmt.value)
                            
            elif isinstance_ControlFlow(stmt_data.stmt):
                # Special case for control flow
                # In our cfg, when we encounter a controlflow node at the end of a BB,
                # we include the whole control flow block, including its body. However,
                # for control flow we only case about usages in the expression, hence the special case
                stmt_data.uses = get_all_names(get_expression_ControlFlow(stmt_data.stmt))
                
            elif isinstance(stmt_data.stmt, cst.CSTNode):
                stmt_data.uses = get_all_names(stmt_data.stmt)
                
            else:
                raise Exception() 
                
            # Find all members of IN set that intersect our use set
            # Because IN is a set of stmts which use is a set of variable names,
            # we have to first map each IN set item to its defined variable names
            for in_set_stmt in stmt_data.ins:
                variables_defined = get_assignment_targets(in_set_stmt)
                defines_a_var_in_use_set = intersects(stmt_data.uses, variables_defined)
                
                if defines_a_var_in_use_set: stmt_data.deps.add(in_set_stmt)
                
            # Find all members of IN set that intersect our kill set
            stmt_data.deps.update(stmt_data.kills.intersection(stmt_data.ins))
                    
    # Print gen/kill
    print()
    for chunk in cfg:
        for stmt_data in chunk.stmts: 
            
            print(first_line(stmt_data.stmt, ast), 
                    # 'gens', [first_line(gen, ast) for gen in stmt_data.gens], \
                    #   '\tkills', [first_line(s, ast) for s in stmt_data.kills], \
                  '\n\tins', stringify(stmt_data.ins, ast), \
                  '\n\touts', stringify(stmt_data.outs, ast), \
                  '\n\tuses', stringify(stmt_data.uses, ast), \
                  '\n\tkills', stringify(stmt_data.kills, ast))
            
            print()
        
    # Print deps
    print()
    for chunk in cfg:
        for stmt_data in chunk.stmts: 
            
            print(first_line(stmt_data.stmt, ast), '\tDEPS:', 
                # 'gens', [first_line(gen, ast) for gen in stmt_data.gens], \
                #   '\tkills', [first_line(s, ast) for s in stmt_data.kills], \
                  ' ', [first_line(s, ast) for s in stmt_data.deps] )
            
            print()
    